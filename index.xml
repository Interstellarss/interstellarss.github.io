<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>my blog for notes</title>
        <link>https://interstellarss.github.io/</link>
        <description>This is my new Hugo sites</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 02 Mar 2022 10:03:37 &#43;0100</lastBuildDate>
            <atom:link href="https://interstellarss.github.io/index.xml" rel="self" type="application/rss+xml" />
        <item>
    <title>Something about ISA Emulation -- 2</title>
    <link>https://interstellarss.github.io/posts/vt/isa_emulation2/</link>
    <pubDate>Wed, 02 Mar 2022 10:03:37 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://interstellarss.github.io/posts/vt/isa_emulation2/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>Something about Process-Virtual-Machine</title>
    <link>https://interstellarss.github.io/posts/vt/process_virtual_machine/</link>
    <pubDate>Thu, 10 Feb 2022 15:50:20 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://interstellarss.github.io/posts/vt/process_virtual_machine/</guid>
    <description><![CDATA[Process VM   Emulation of a user-level process (with possibly different ISA, different OS) – components required? – techniques? – correctness verification?
  Process VM with same OS, same ISA – use case?
 motivation  process migration flexible control of used OS resources   „OS-level virtualization“ enough not discussed here    Virtualization of a process environment
 emulation of user ISA + OS environment (ABI) every guest process gets own environment guest and host OS often the same    View of the host machine user]]></description>
</item><item>
    <title>Something about ISA Emulation -- 1</title>
    <link>https://interstellarss.github.io/posts/vt/isa_emulation1/</link>
    <pubDate>Tue, 16 Nov 2021 20:50:20 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://interstellarss.github.io/posts/vt/isa_emulation1/</guid>
    <description><![CDATA[A complete ISA consists of many parts, including the register set and memory architecture, the instructions , and the trap and interrupt architecture. A virtual machine implementation is usually concerned with all aspects of ISA emulation.
Here we will be focusing on (user-level) instruction emulation.
Instruction set emulation can be carried out basiclly in 2 techniques: interpretation, and binary translation.
 Interpretation involves a cycle of fetching a source instrction, analyzing it, performing the required operation, and then fetching the next source instruction &ndash; all in software.]]></description>
</item><item>
    <title>Relational Model and Relational Algebra</title>
    <link>https://interstellarss.github.io/posts/database/datenbank-3/</link>
    <pubDate>Sun, 15 Nov 2020 11:34:02 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://interstellarss.github.io/posts/database/datenbank-3/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>Different Approaches to 「Rotation」</title>
    <link>https://interstellarss.github.io/posts/imge/imge-1_en/</link>
    <pubDate>Tue, 10 Nov 2020 16:08:41 &#43;0100</pubDate>
    <author>Author</author>
    <guid>https://interstellarss.github.io/posts/imge/imge-1_en/</guid>
    <description><![CDATA[]]></description>
</item><item>
    <title>The network layer as a &#39;lead&#39; expert</title>
    <link>https://interstellarss.github.io/posts/computernetwork/network-layer_en/</link>
    <pubDate>Mon, 06 Jul 2020 23:16:59 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://interstellarss.github.io/posts/computernetwork/network-layer_en/</guid>
    <description><![CDATA[Here we will recognize the two different services provided by the network layer and the core of the network layer, namely the IP protocol. We can understand:
 the concept of virtual interconnection networks. the relationship between IP addresses and physical addresses the traditional classification of IP addresses (including subnet masks)  Address Resolution Protocol ARP In practical applications, we often encounter the problem that we already know the IP address of a machine (host or router) and need to find out its corresponding hardware address.]]></description>
</item><item>
    <title>What we&#39;re talking about when we talk about shared memory parallelism - Boosting</title>
    <link>https://interstellarss.github.io/posts/seminar-hpc/shared-memory-parallelism_2/</link>
    <pubDate>Sun, 07 Jun 2020 21:44:12 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://interstellarss.github.io/posts/seminar-hpc/shared-memory-parallelism_2/</guid>
    <description><![CDATA[This time, I brought the first draft of the paper to be submitted for the seminar, which is a way to be lazy.
A brief Overview on Shared Memory Parallelism in Parallel Computing 1. Why parallel? To speed up, while we are facing the limitation of current transistors and increasing energy consumption. Now that we know it is necessary and lots of privilege besides you need to reconstruct your program yourself rather than automatically distributed by APIs in a serial way.]]></description>
</item><item>
    <title>Generation of height maps based on diamond-square-algorithm in C&#43;&#43;</title>
    <link>https://interstellarss.github.io/posts/computer_graphics/implementation-about-diamond-square/</link>
    <pubDate>Thu, 21 May 2020 11:38:08 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://interstellarss.github.io/posts/computer_graphics/implementation-about-diamond-square/</guid>
    <description><![CDATA[In fact, many times we see these renderings are really amazing things, such as some terrain seems to be three-dimensional, but in fact can be generated by two-dimensional, that is, for each pixel point to give a height value, these height values constitute a column of points and can be converted into a two-dimensional image to store, when needed, the corresponding terrain can be generated from this picture.
As for the introduction, we are only concerned with using normal distribution or diamond square to assign values, terrain generator about color and normal value images we will talk about later.]]></description>
</item><item>
    <title>DFA and NFA -- 2</title>
    <link>https://interstellarss.github.io/posts/theo/something-about-dfa-and-nfa-2/</link>
    <pubDate>Thu, 14 May 2020 23:56:46 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://interstellarss.github.io/posts/theo/something-about-dfa-and-nfa-2/</guid>
    <description><![CDATA[From part 1 we can recognize what DFA and NFA look like and know the equivalence between them. In &ldquo;From Infinite Automata to Regular Languages&rdquo; we know the equivalence between DFA, NFA and regular expressions and regular languages, and there are some tools such as pump priming and Ardens Lemma to either prove or convert them. We have made some progress in the &lsquo;art&rsquo; level so far, so we might]]></description>
</item><item>
    <title>Functionally important and single data link layer</title>
    <link>https://interstellarss.github.io/posts/computernetwork/data-link-layer_en/</link>
    <pubDate>Tue, 12 May 2020 09:44:32 &#43;0200</pubDate>
    <author>Author</author>
    <guid>https://interstellarss.github.io/posts/computernetwork/data-link-layer_en/</guid>
    <description><![CDATA[Verbindungscharakterisierung The connection between two nodes will have various properties as follows：Übertragungsrate, Übertragungsverzögerung, Übertragun]]></description>
</item></channel>
</rss>
